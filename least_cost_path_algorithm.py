# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LeastCostPath
                                 A QGIS plugin
 Find the least cost path with given cost raster and points
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
         begin                : 2018-12-12
        copyright            : (C) 2018 by FlowMap Group@SESS.PKU
        email                : xurigong@gmail.com
 ************************* **************************************************/

/***************************************************************************
 * *
 * This program is free software; you can redistribute it and/or modify  *
 * it under the terms of the GNU General Public License as published by  * * the Free Software Foundation; either version 2 of the License, or     *
 * (at your option) any later version.                                   *
 * *
 ***************************************************************************/
"""

# Metadados do plugin: autor, data e copyright.
__author__ = 'FlowMap Group@SESS.PKU'
__date__ = '2018-12-12'
__copyright__ = '(C) 2018 by FlowMap Group@SESS.PKU'

# Variável de revisão Git, usada para controle de versão em ambientes Git.
__revision__ = '$Format:%H$'

# Importações necessárias das bibliotecas PyQt5 para interface gráfica e QGIS para funcionalidades geoespaciais.
from PyQt5.QtCore import QCoreApplication, QVariant
from PyQt5.QtGui import QIcon
from qgis.core import (
    QgsFeature,
    QgsGeometry,
    QgsPoint,
    QgsField,
    QgsFields,
    QgsWkbTypes,
    QgsProcessing,
    QgsFeatureSink,
    QgsProcessingException,
    QgsProcessingAlgorithm,
    QgsProcessingParameterFeatureSource,
    QgsProcessingParameterFeatureSink,
    QgsProcessingParameterRasterLayer,
    QgsProcessingParameterBand,
    QgsProcessingParameterBoolean,
    QgsRasterBlock,
    Qgis # ADIÇÃO: Importar Qgis para acessar Qgis.DataType
)
import processing
from .dijkstra_algorithm import dijkstra
from math import floor
import numpy as np


class LeastCostPathAlgorithm(QgsProcessingAlgorithm):
    """
    Esta é a implementação do algoritmo do Caminho de Menor Custo que utiliza o algoritmo de Dijkstra.
    """

    INPUT_COST_RASTER = 'INPUT_COST_RASTER'
    INPUT_RASTER_BAND = 'INPUT_RASTER_BAND'
    INPUT_START_LAYER = 'INPUT_START_LAYER'
    INPUT_END_LAYER = 'INPUT_END_LAYER'
    BOOLEAN_FIND_LEAST_PATH_TO_ALL_ENDS = 'BOOLEAN_FIND_LEAST_PATH_TO_ALL_ENDS'
    BOOLEAN_OUTPUT_LINEAR_REFERENCE = 'BOOLEAN_OUTPUT_LINEAR_REFERENCE'

    INPUT_RIVERS_RASTER = 'INPUT_RIVERS_RASTER'
    INPUT_RIVERS_BAND = 'INPUT_RIVERS_BAND'
    INPUT_URBAN_RASTER = 'INPUT_URBAN_RASTER'
    INPUT_URBAN_BAND = 'INPUT_URBAN_BAND'
    INPUT_VEGETATION_RASTER = 'INPUT_VEGETATION_RASTER'
    INPUT_VEGETATION_BAND = 'INPUT_VEGETATION_BAND'

    OUTPUT = 'OUTPUT'

    def initAlgorithm(self, config=None):
        """
        Define os parâmetros de entrada e saída do algoritmo de processamento do QGIS.
        Este método é chamado pelo framework de processamento para configurar a interface do algoritmo.
        """
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_COST_RASTER,
                self.tr('Cost raster layer'),
            )
        )

        self.addParameter(
            QgsProcessingParameterBand(
                self.INPUT_RASTER_BAND,
                self.tr('Cost raster band'),
                defaultValue=1,
                parentLayerParameterName=self.INPUT_COST_RASTER,
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_START_LAYER,
                self.tr('Start-point layer'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_END_LAYER,
                self.tr('End-point(s) layer'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_RIVERS_RASTER,
                self.tr('Rivers cost raster layer (optional)'),
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterBand(
                self.INPUT_RIVERS_BAND,
                self.tr('Rivers cost raster band (optional)'),
                defaultValue=1,
                parentLayerParameterName=self.INPUT_RIVERS_RASTER,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_URBAN_RASTER,
                self.tr('Urban Perimeter cost raster layer (optional)'),
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterBand(
                self.INPUT_URBAN_BAND,
                self.tr('Urban Perimeter cost raster band (optional)'),
                defaultValue=1,
                parentLayerParameterName=self.INPUT_URBAN_RASTER,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_VEGETATION_RASTER,
                self.tr('Vegetation cost raster layer (optional)'),
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterBand(
                self.INPUT_VEGETATION_BAND,
                self.tr('Vegetation cost raster band (optional)'),
                defaultValue=1,
                parentLayerParameterName=self.INPUT_VEGETATION_RASTER,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.BOOLEAN_FIND_LEAST_PATH_TO_ALL_ENDS,
                self.tr('Only connect with the nearest end points'),
                defaultValue=False
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.BOOLEAN_OUTPUT_LINEAR_REFERENCE,
                self.tr('Include linear referencing (PolylineM type)'),
                defaultValue=False
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output least cost path')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Executa a lógica principal do algoritmo de cálculo do caminho de menor custo.
        Este método é chamado quando o usuário executa o algoritmo.
        """
        feedback.setProgress(1)

        cost_raster = self.parameterAsRasterLayer(parameters, self.INPUT_COST_RASTER, context)
        cost_raster_band = self.parameterAsInt(parameters, self.INPUT_RASTER_BAND, context)
        start_source = self.parameterAsSource(parameters, self.INPUT_START_LAYER, context)
        end_source = self.parameterAsSource(parameters, self.INPUT_END_LAYER, context)
        find_nearest = self.parameterAsBool(parameters, self.BOOLEAN_FIND_LEAST_PATH_TO_ALL_ENDS, context)
        output_linear_reference = self.parameterAsBool(parameters, self.BOOLEAN_OUTPUT_LINEAR_REFERENCE, context)

        rivers_raster = self.parameterAsRasterLayer(parameters, self.INPUT_RIVERS_RASTER, context)
        rivers_band = self.parameterAsInt(parameters, self.INPUT_RIVERS_BAND, context) if rivers_raster else None

        urban_raster = self.parameterAsRasterLayer(parameters, self.INPUT_URBAN_RASTER, context)
        urban_band = self.parameterAsInt(parameters, self.INPUT_URBAN_BAND, context) if urban_raster else None

        vegetation_raster = self.parameterAsRasterLayer(parameters, self.INPUT_VEGETATION_RASTER, context)
        vegetation_band = self.parameterAsInt(parameters, self.INPUT_VEGETATION_BAND, context) if vegetation_raster else None


        if not cost_raster or not cost_raster.isValid():
            raise QgsProcessingException("O raster de custo principal é inválido.")
        if not start_source:
            raise QgsProcessingException("A camada de ponto inicial é inválida.")
        if not end_source:
            raise QgsProcessingException("A camada de ponto(s) final(is) é inválida.")

        if cost_raster.crs() != start_source.sourceCrs():
            raise QgsProcessingException(f"O CRS da camada de ponto inicial ({start_source.sourceCrs().authid()}) difere do CRS do raster de custo ({cost_raster.crs().authid()}).")
        if cost_raster.crs() != end_source.sourceCrs():
            raise QgsProcessingException(f"O CRS da camada de ponto(s) final(is) ({end_source.sourceCrs().authid()}) difere do CRS do raster de custo ({cost_raster.crs().authid()}).")

        if rivers_raster and rivers_raster.crs() != cost_raster.crs():
            raise QgsProcessingException(f"O raster de custo de Rios ({rivers_raster.crs().authid()}) tem um CRS diferente do raster de custo principal ({cost_raster.crs().authid()}).")
        if urban_raster and urban_raster.crs() != cost_raster.crs():
            raise QgsProcessingException(f"O raster de custo de Perímetro Urbano ({urban_raster.crs().authid()}) tem um CRS diferente do raster de custo principal ({cost_raster.crs().authid()}).")
        if vegetation_raster and vegetation_raster.crs() != cost_raster.crs():
            raise QgsProcessingException(f"O raster de custo de Vegetação ({vegetation_raster.crs().authid()}) tem um CRS diferente do raster de custo principal ({cost_raster.crs().authid()}).")

        if cost_raster.rasterType() not in [cost_raster.Multiband, cost_raster.GrayOrUndefined]:
            raise QgsProcessingException("O raster de custo principal não é numérico.")

        if rivers_raster and rivers_raster.rasterType() not in [rivers_raster.Multiband, rivers_raster.GrayOrUndefined]:
            raise QgsProcessingException("O raster de custo de Rios não é numérico.")
        if urban_raster and urban_raster.rasterType() not in [urban_raster.Multiband, urban_raster.GrayOrUndefined]:
            raise QgsProcessingException("O raster de custo de Perímetro Urbano não é numérico.")
        if vegetation_raster and vegetation_raster.rasterType() not in [vegetation_raster.Multiband, vegetation_raster.GrayOrUndefined]:
            raise QgsProcessingException("O raster de custo de Vegetação não é numérico.")


        sink_fields = MinCostPathHelper.create_fields()
        output_geometry_type = QgsWkbTypes.LineStringM if output_linear_reference else QgsWkbTypes.LineString
        sink, dest_id = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            fields=sink_fields,
            geometryType=output_geometry_type,
            crs=cost_raster.crs(),
        )

        if not sink:
            raise QgsProcessingException("Falha ao criar o destino de saída.")

        start_features = list(start_source.getFeatures())
        end_features = list(end_source.getFeatures())

        start_tuples = MinCostPathHelper.features_to_tuples(start_features, cost_raster)
        if len(start_features) > 0 and len(start_tuples) == 0:
            raise QgsProcessingException("Nenhum ponto inicial válido encontrado dentro da extensão do raster de custo. Verifique se os pontos estão dentro dos limites do raster.")
        elif len(start_tuples) == 0:
            raise QgsProcessingException("A camada de ponto inicial não contém nenhum ponto legal.")
        elif len(start_tuples) > 1:
            raise QgsProcessingException("A camada de ponto inicial contém mais de um ponto legal. Por favor, forneça apenas um ponto inicial.")
        start_tuple = start_tuples[0]

        end_tuples = MinCostPathHelper.features_to_tuples(end_features, cost_raster)
        if len(end_features) > 0 and len(end_tuples) == 0:
            raise QgsProcessingException("Nenhum ponto final válido encontrado dentro da extensão do raster de custo. Verifique se os pontos estão dentro dos limites do raster.")
        elif len(end_tuples) == 0:
            raise QgsProcessingException("A camada de ponto(s) final(is) não contém nenhum ponto legal.")

        block_main = MinCostPathHelper.get_all_block(cost_raster, cost_raster_band)
        matrix_main_np, contains_negative_main = MinCostPathHelper.block2matrix(block_main)

        if contains_negative_main:
            raise QgsProcessingException("O raster de custo principal contém valores negativos. Por favor, use apenas valores não negativos.")

        matrix_height = block_main.height()
        matrix_width = block_main.width()

        feedback.pushInfo(f"O tamanho do raster de custo é: {matrix_height} * {matrix_width}")

        consolidated_matrix_np = MinCostPathHelper.combine_cost_rasters(
            matrix_main_np, matrix_height, matrix_width,
            rivers_raster, rivers_band,
            urban_raster, urban_band,
            vegetation_raster, vegetation_band,
            cost_raster, feedback
        )

        feedback.pushInfo("Procurando o caminho de menor custo...")

        result = dijkstra(start_tuple, end_tuples, consolidated_matrix_np, find_nearest, feedback)

        if result is None:
            raise QgsProcessingException("Pesquisa cancelada.")
        if len(result) == 0:
            raise QgsProcessingException("Os pontos finais não são alcançáveis a partir do ponto inicial.")

        feedback.setProgress(100)
        feedback.pushInfo("Pesquisa concluída! Salvando caminho...")

        for path, costs, terminal_tuples in result:
            for terminal_tuple in terminal_tuples:
                path_points = MinCostPathHelper.create_points_from_path(cost_raster, path, start_tuple[1], terminal_tuple[1])

                if output_linear_reference:
                    for point, cost in zip(path_points, costs):
                        point.addMValue(cost)

                total_cost = costs[-1]
                feature = MinCostPathHelper.create_path_feature_from_points(path_points, (start_tuple[2], terminal_tuple[2], total_cost), sink_fields)
                sink.addFeature(feature, QgsFeatureSink.FastInsert)

        return {self.OUTPUT: dest_id}

    def name(self):
        return 'LeastCostPath'

    def displayName(self):
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return LeastCostPathAlgorithm()

    def helpUrl(self):
        return 'https://github.com/Gooong/LeastCostPath'

    def shortHelpString(self):
        return self.tr("""
        Por favor, garanta que todas as camadas de entrada tenham o mesmo CRS.

        - Camada de raster de custo: Camada de raster numérica que representa o custo de cada unidade espacial. Não deve conter valores negativos. Pixels com `NoData` representam áreas inatingíveis.

        - Banda do raster de custo: A banda de entrada do raster de custo.

        - Camada de ponto inicial: Camada que contém apenas um ponto inicial.

        - Camada de ponto(s) final(is): Camada que contém o(s) ponto(s) de destino.

        - Camada de raster de custo de Rios (opcional): Uma camada de raster numérica opcional que representa custo adicional para rios. Seu CRS e dimensões devem corresponder ao raster de custo principal.

        - Banda do raster de custo de Rios (opcional): A banda de entrada para o raster de custo de rios.

        - Camada de raster de custo de Perímetro Urbano (opcional): Uma camada de raster numérica opcional. Áreas com valores válidos (não NoData) neste raster serão consideradas altamente restritivas, e o caminho evitará passar por elas. Seu CRS e dimensões devem corresponder ao raster de custo principal.

        - Banda do raster de custo de Perímetro Urbano (opcional): A banda de entrada para o raster de custo de perímetro urbano.

        - Camada de raster de custo de Vegetação (opcional): Uma camada de raster numérica opcional que representa custo adicional para vegetação. Seu CRS e dimensões devem corresponder ao raster de custo principal.

        - Banda do raster de custo de Vegetação (opcional): A banda de entrada para o raster de custo de vegetação.

        - Conectar apenas com os pontos finais mais próximos: Se mais de um destino for fornecido, ele encontrará o caminho de menor custo para todos os pontos finais por padrão. Se ativado, o caminho de menor custo conectará o ponto inicial apenas com o ponto final mais próximo.

        - [Opcional] Incluir referenciação linear (PolylineM type): Se selecionado, este algoritmo produzirá o caminho de menor custo no tipo `PolylineM`, com o custo acumulado como valor de referenciação linear.
        """)

    def shortDescription(self):
        return self.tr('Encontra o caminho de menor custo com base em um raster de custo e pontos fornecidos.')

    def svgIconPath(self):
        return ''

    def tags(self):
        return ['least', 'cost', 'path', 'distance', 'raster', 'analysis', 'road']


class MinCostPathHelper:
    """
    Classe auxiliar que contém métodos estáticos para operações comuns relacionadas ao cálculo do caminho de menor custo,
    como conversão de coordenadas, manipulação de rasters e criação de feições.
    """

    @staticmethod
    def _point_to_row_col(pointxy, raster_layer):
        """
        Converte as coordenadas de um ponto geográfico (QgsPoint) para as coordenadas de linha e coluna
        correspondentes em um raster.
        """
        xres = raster_layer.rasterUnitsPerPixelX()
        yres = raster_layer.rasterUnitsPerPixelY()
        extent = raster_layer.dataProvider().extent()

        col = floor((pointxy.x() - extent.xMinimum()) / xres)
        row = floor((extent.yMaximum() - pointxy.y()) / yres)

        if not (0 <= row < raster_layer.height() and 0 <= col < raster_layer.width()):
            return None

        return row, col

    @staticmethod
    def _row_col_to_point(row_col, raster_layer):
        """
        Converte as coordenadas de linha e coluna de um raster de volta para as coordenadas geográficas
        (QgsPoint) do centro do pixel.
        """
        xres = raster_layer.rasterUnitsPerPixelX()
        yres = raster_layer.rasterUnitsPerPixelY()
        extent = raster_layer.dataProvider().extent()

        x = (row_col[1] + 0.5) * xres + extent.xMinimum()
        y = extent.yMaximum() - (row_col[0] + 0.5) * yres
        return QgsPoint(x, y)

    @staticmethod
    def create_points_from_path(cost_raster, min_cost_path, start_point_orig, end_point_orig):
        """
        Cria uma lista de objetos QgsPoint a partir de uma lista de tuplas (linha, coluna) que representam
        o caminho de menor custo. Ajusta as coordenadas dos pontos inicial e final para os pontos de entrada originais.
        """
        path_points = list(map(lambda row_col: MinCostPathHelper._row_col_to_point(row_col, cost_raster), min_cost_path))

        if path_points:
            path_points[0].setX(start_point_orig.x())
            path_points[0].setY(start_point_orig.y())
            path_points[-1].setX(end_point_orig.x())
            path_points[-1].setY(end_point_orig.y())
        return path_points

    @staticmethod
    def create_fields():
        """
        Cria a definição dos campos (colunas) para a tabela de atributos da camada de saída.
        """
        start_field = QgsField("start point id", QVariant.Int, "int")
        end_field = QgsField("end point id", QVariant.Int, "int")
        cost_field = QgsField("total cost", QVariant.Double, "double", 10, 3)
        fields = QgsFields()
        fields.append(start_field)
        fields.append(end_field)
        fields.append(cost_field)
        return fields

    @staticmethod
    def create_path_feature_from_points(path_points, attr_vals, fields):
        """
        Cria um objeto QgsFeature (uma feição geográfica) a partir de uma lista de pontos e valores de atributos.
        """
        polyline = QgsGeometry.fromPolyline(path_points)
        feature = QgsFeature(fields)

        start_index = feature.fieldNameIndex("start point id")
        end_index = feature.fieldNameIndex("end point id")
        cost_index = feature.fieldNameIndex("total cost")

        feature.setAttribute(start_index, attr_vals[0])
        feature.setAttribute(end_index, attr_vals[1])
        feature.setAttribute(cost_index, attr_vals[2]) # cost
        feature.setGeometry(polyline)
        return feature

    @staticmethod
    def features_to_tuples(point_features, raster_layer):
        """
        Converte uma lista de feições de ponto (QgsFeature) em uma lista de tuplas formatadas como
        ((linha, coluna), QgsPoint original, ID da feição).
        Apenas pontos que caem dentro da extensão do raster são incluídos.
        """
        row_cols = []
        extent = raster_layer.dataProvider().extent()

        for point_feature in point_features:
            if point_feature.hasGeometry():
                point_geom = point_feature.geometry()
                if point_geom.wkbType() == QgsWkbTypes.MultiPoint:
                    multi_points = point_geom.asMultiPoint()
                    for pointxy in multi_points:
                        if extent.contains(pointxy):
                            row_col = MinCostPathHelper._point_to_row_col(pointxy, raster_layer)
                            if row_col is not None:
                                row_cols.append((row_col, pointxy, point_feature.id()))
                elif point_geom.wkbType() == QgsWkbTypes.Point:
                    pointxy = point_geom.asPoint()
                    if extent.contains(pointxy):
                        row_col = MinCostPathHelper._point_to_row_col(pointxy, raster_layer)
                        if row_col is not None:
                            row_cols.append((row_col, pointxy, point_feature.id()))

        return row_cols

    @staticmethod
    def get_all_block(raster_layer, band_num):
        """
        Obtém um bloco de dados completo (todos os pixels) de uma banda específica de um raster.
        """
        provider = raster_layer.dataProvider()
        extent = provider.extent()

        width = raster_layer.width()
        height = raster_layer.height()

        if width <= 0 or height <= 0:
            raise QgsProcessingException(f"O raster '{raster_layer.name()}' tem dimensões inválidas (largura: {width}, altura: {height}).")

        return provider.block(band_num, extent, width, height)

    @staticmethod
    def block2matrix(block):
        """
        Converte um bloco de dados de raster (QgsRasterBlock) em uma matriz NumPy 2D.
        Valores NoData são convertidos para np.nan.
        Também verifica se a matriz contém valores negativos (ignorando np.nan).
        """
        # Determine the NumPy dtype from QgsRasterBlock's data type
        qgis_data_type = block.dataType()
        # Mapping QGIS data types to NumPy dtypes using Qgis.DataType
        if qgis_data_type == Qgis.DataType.Byte:
            numpy_dtype = np.uint8
        elif qgis_data_type == Qgis.DataType.UInt16:
            numpy_dtype = np.uint16
        elif qgis_data_type == Qgis.DataType.Int16:
            numpy_dtype = np.int16
        elif qgis_data_type == Qgis.DataType.UInt32:
            numpy_dtype = np.uint32
        elif qgis_data_type == Qgis.DataType.Int32:
            numpy_dtype = np.int32
        elif qgis_data_type == Qgis.DataType.Float32:
            numpy_dtype = np.float32
        elif qgis_data_type == Qgis.DataType.Float64:
            numpy_dtype = np.float64
        else:
            raise QgsProcessingException(f"Tipo de dado de raster não suportado: {qgis_data_type}")

        # Convert QByteArray to NumPy array using np.frombuffer
        # and reshape it to the correct dimensions (height, width).
        # Ensure the final array is float64 to support np.nan and np.inf.
        matrix_np = np.frombuffer(block.data(), dtype=numpy_dtype).reshape(block.height(), block.width()).astype(np.float64)

        # Get NoData value from the block (if applicable)
        no_data_value = block.noDataValue()
        if no_data_value is not None:
            # Replace NoData values with np.nan
            matrix_np[matrix_np == no_data_value] = np.nan

        # Check for negative values, ignoring np.nan
        contains_negative = np.any((matrix_np < 0) & (~np.isnan(matrix_np)))

        return matrix_np, contains_negative

    @staticmethod
    def combine_cost_rasters(main_matrix_np, height, width,
                             rivers_raster_obj, rivers_band_num,
                             urban_raster_obj, urban_band_num,
                             vegetation_raster_obj, vegetation_band_num,
                             cost_raster_main, feedback):
        """
        Combina múltiplos rasters de custo (principal e opcionais) em uma única matriz de custo consolidada.
        Trata valores NoData (como np.nan) e aplica lógica específica para cada tipo de raster de custo.
        Tudo usando operações NumPy vetorizadas.
        """
        # Inicializa a matriz consolidada com valores do raster principal.
        # np.copy() para evitar modificar o array original.
        consolidated_matrix = np.copy(main_matrix_np)

        # Pixels com np.nan no raster principal são tratados como np.inf (inacessíveis) no modelo de custo.
        consolidated_matrix[np.isnan(consolidated_matrix)] = np.inf

        # Processa as camadas de custo aditivas (Rios, Vegetação).
        additive_rasters_info = []
        if rivers_raster_obj and rivers_band_num is not None:
            additive_rasters_info.append((rivers_raster_obj, rivers_band_num, "Rios"))
        if vegetation_raster_obj and vegetation_band_num is not None:
            additive_rasters_info.append((vegetation_raster_obj, vegetation_band_num, "Vegetação"))

        for opt_raster, opt_band, name in additive_rasters_info:
            block_opt = MinCostPathHelper.get_all_block(opt_raster, opt_band)
            matrix_opt_np, contains_negative_opt = MinCostPathHelper.block2matrix(block_opt)

            if contains_negative_opt:
                raise QgsProcessingException(f"O raster de custo de {name} contém valores negativos. Por favor, use apenas valores não negativos.")

            if block_opt.height() != height or block_opt.width() != width:
                raise QgsProcessingException(f"O raster de custo de {name} tem dimensões diferentes do raster de custo principal. As dimensões devem ser as mesmas.")

            # Adiciona o custo do raster opcional, mas apenas onde não é NaN no raster opcional
            # E onde a matriz consolidada atual não é np.inf (ou seja, já não é um obstáculo).
            valid_add_mask = (~np.isnan(matrix_opt_np)) & (~np.isinf(consolidated_matrix))
            consolidated_matrix[valid_add_mask] += matrix_opt_np[valid_add_mask]

        # Processa o raster de Perímetro Urbano com comportamento restritivo (tornar áreas proibitivas).
        if urban_raster_obj and urban_band_num is not None:
            block_urban = MinCostPathHelper.get_all_block(urban_raster_obj, urban_band_num)
            matrix_urban_np, contains_negative_urban = MinCostPathHelper.block2matrix(block_urban)

            if contains_negative_urban:
                raise QgsProcessingException("O raster de custo de Perímetro Urbano contém valores negativos. Por favor, use apenas valores não negativos.")

            if block_urban.height() != height or block_urban.width() != width:
                raise QgsProcessingException("O raster de custo de Perímetro Urbano tem dimensões diferentes do raster de custo principal. As dimensões devem ser as mesmas.")

            # Onde o raster urbano tem um valor (não é NaN), a célula se torna np.inf (inacessível).
            # Aplica np.inf apenas onde o raster urbano NÃO é NaN.
            consolidated_matrix[~np.isnan(matrix_urban_np)] = np.inf

        return consolidated_matrix