# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LeastCostPath
                                 A QGIS plugin
 Find the least cost path with given cost raster and points
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-12-12
        copyright            : (C) 2018 by FlowMap Group@SESS.PKU
        email                : xurigong@gmail.com
 ***************************************************************************/

/***************************************************************************
 * *
 * This program is free software; you can redistribute it and/or modify  *
 * it under the terms of the GNU General Public License as published by  *
 * the Free Software Foundation; either version 2 of the License, or     *
 * (at your option) any later version.                                   *
 * *
 ***************************************************************************/
"""

__author__ = 'FlowMap Group@SESS.PKU'
__date__ = '2018-12-12'
__copyright__ = '(C) 2018 by FlowMap Group@SESS.PKU'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from math import sqrt
import queue
import collections
import numpy as np


class Grid:
    """
    Represents the grid for the Dijkstra algorithm.
    This class encapsulates the grid's properties and methods related to its structure,
    such as checking boundaries, passability, and finding neighbors.
    """

    def __init__(self, matrix):
        self.map = matrix  # A matriz que representa o mapa de custos ou obstáculos.
        self.h = matrix.shape[0]  # Altura da grade (número de linhas).
        self.w = matrix.shape[1]  # Largura da grade (número de colunas).
        self.sqrt2 = sqrt(2)  # Valor pré-calculado de raiz de 2, usado para custos de movimentos diagonais.

    def _in_bounds(self, id):
        """
        Check if the given coordinates (x, y) are within the grid boundaries.
        Args:
            id (tuple): A tupla (x, y) representando as coordenadas.
        Returns:
            bool: True se estiver dentro dos limites, False caso contrário.
        """
        x, y = id
        return 0 <= x < self.h and 0 <= y < self.w

    def _passable(self, id):
        """
        Check if the given cell is passable (its cost is not None, or more specifically, not NaN or infinity).
        Args:
            id (tuple): A tupla (x, y) representando as coordenadas.
        Returns:
            bool: True se a célula não for NaN ou infinito (passável), False caso contrário.
        """
        x, y = id
        cell_value = self.map[x, y]
        return not np.isnan(cell_value) and not np.isinf(cell_value)

    def is_valid(self, id):
        """
        Check if the given cell is both in bounds and passable.
        This is a convenience method that combines _in_bounds and _passable checks.
        Args:
            id (tuple): A tupla (x, y) representando as coordenadas.
        Returns:
            bool: True se a célula for válida para travessia, False caso contrário.
        """
        return self._in_bounds(id) and self._passable(id)

    def neighbors(self, id):
        """
        Return all valid neighboring cells (both cardinal and diagonal) for the given cell.
        Args:
            id (tuple): A tupla (x, y) representando as coordenadas da célula atual.
        Returns:
            list: Uma lista de tuplas (nx, ny) representando as coordenadas dos vizinhos válidos.
        """
        x, y = id
        results = [
            (x + 1, y), (x, y - 1), (x - 1, y), (x, y + 1),  # Direções Cardeais (cima, baixo, esquerda, direita)
            (x + 1, y - 1), (x + 1, y + 1), (x - 1, y - 1), (x - 1, y + 1)  # Direções Diagonais
        ]
        return list(filter(self.is_valid, results))

    @staticmethod
    def manhattan_distance(id1, id2):
        """
        Calculate the Manhattan distance between two points (ids).
        The Manhattan distance (or taxicab geometry) is the sum of the absolute differences
        of their Cartesian coordinates.
        Args:
            id1 (tuple): Coordenadas (x1, y1) do primeiro ponto.
            id2 (tuple): Coordenadas (x2, y2) do segundo ponto.
        Returns:
            int: A distância Manhattan.
        """
        x1, y1 = id1
        x2, y2 = id2
        return abs(x1 - x2) + abs(y1 - y2)

    @staticmethod
    def min_manhattan(curr_node, end_nodes):
        """
        Calculate the minimum Manhattan distance from the current node to any of the end nodes.
        Args:
            curr_node (tuple): Coordenadas do nó atual.
            end_nodes (iterable): Uma coleção de tuplas de coordenadas dos nós de destino.
        Returns:
            int: A menor distância Manhattan encontrada.
        """
        return min(Grid.manhattan_distance(curr_node, node) for node in end_nodes)

    @staticmethod
    def max_manhattan(curr_node, end_nodes):
        """
        Calculate the maximum Manhattan distance from the current node to any of the end nodes.
        Args:
            curr_node (tuple): Coordenadas do nó atual.
            end_nodes (iterable): Uma coleção de tuplas de coordenadas dos nós de destino.
        Returns:
            int: A maior distância Manhattan encontrada.
        """
        return max(Grid.manhattan_distance(curr_node, node) for node in end_nodes)

    def simple_cost(self, cur, nex):
        """
        Calculate the cost of moving from one cell (current) to another (next).
        The cost is the average of the values of the current and next cells in the grid,
        adjusted by sqrt(2) for diagonal movements.
        Args:
            cur (tuple): Coordenadas (cx, cy) da célula atual.
            nex (tuple): Coordenadas (nx, ny) da próxima célula.
        Returns:
            float: O custo de travessia entre as duas células.
        """
        cx, cy = cur
        nx, ny = nex
        currV = self.map[cx, cy]
        offsetV = self.map[nx, ny]

        if cx == nx or cy == ny:
            return (currV + offsetV) / 2
        else:
            return self.sqrt2 * (currV + offsetV) / 2


def dijkstra(start_tuple, end_tuples, block, find_nearest, feedback=None):
    """
    Implementation of Dijkstra's algorithm to find the least cost path(s) on a grid.
    This function finds either the path to the nearest end point or paths to all
    specified end points, based on the 'find_nearest' flag.

    Parameters:
        start_tuple (tuple): Uma tupla contendo as informações do ponto de partida.
                             Assume-se que o primeiro elemento é uma tupla (row, col).
        end_tuples (list): Uma lista de tuplas contendo as informações dos pontos de chegada.
                           Cada tupla de chegada também assume que o primeiro elemento é (row, col).
        block (numpy.ndarray): A matriz de custos (grid) representando o terreno, agora um array NumPy.
        find_nearest (bool): Se True, o algoritmo para após encontrar o primeiro (o mais próximo)
                             ponto de chegada. Se False, continua até encontrar todos os pontos de chegada.
        feedback (QgsFeedback | None): Um objeto de feedback opcional (do QGIS, por exemplo) para
                                      relatar o progresso e verificar o cancelamento do processo.

    Returns:
        list: Uma lista de tuplas. Cada tupla contém:
              (path, costs, terminal_tuples)
              - path (list of tuples): Uma lista de coordenadas (row, col) que formam o caminho.
              - costs (list of floats): Os custos acumulados correspondentes a cada ponto no caminho.
              - terminal_tuples (list): A lista original de tuplas de destino que correspondem ao final do caminho.
        Returns None if the process is canceled via feedback.
    """
    result = []

    grid = Grid(block)

    end_dict = collections.defaultdict(list)
    for end_tuple in end_tuples:
        end_dict[end_tuple[0]].append(end_tuple)
    end_row_cols = set(end_dict.keys())
    end_row_col_list = list(end_row_cols)
    start_row_col = start_tuple[0]

    if not grid.is_valid(start_row_col):
        return result

    frontier = queue.PriorityQueue()
    frontier.put((0, start_row_col))
    came_from = {}
    cost_so_far = {}
    decided = set()

    distance_dic = {node: Grid.manhattan_distance(start_row_col, node) for node in end_row_col_list}
    total_manhattan = sum(distance_dic.values()) if not find_nearest else min(distance_dic.values())
    total_manhattan = max(1, total_manhattan)
    bound = total_manhattan

    if feedback:
        feedback.setProgress(1 + 100 * (1 - bound / total_manhattan))

    came_from[start_row_col] = None
    cost_so_far[start_row_col] = 0

    index_progress = 0

    while not frontier.empty():
        _, current_node = frontier.get()

        if current_node in decided:
            continue
        decided.add(current_node)

        if feedback and feedback.isCanceled():
            return None

        if end_row_col_list:
            target_node = end_row_col_list[index_progress % len(end_row_col_list)]
            new_manhattan = Grid.manhattan_distance(current_node, target_node)

            if new_manhattan < distance_dic[target_node]:
                old_manhattan_for_target = distance_dic[target_node]
                distance_dic[target_node] = new_manhattan

                if find_nearest:
                    current_min_manhattan = min(distance_dic.values())
                    if current_min_manhattan < bound:
                        bound = current_min_manhattan
                else:
                    bound = bound - (old_manhattan_for_target - new_manhattan)

                if feedback:
                    progress_ratio = max(0.0, 1.0 - (bound / total_manhattan))
                    feedback.setProgress(1 + int(100 * (progress_ratio ** 2)))
            index_progress += 1


        if current_node in end_row_cols:
            path = []
            costs = []
            traverse_node = current_node

            while traverse_node is not None:
                path.append(traverse_node)
                costs.append(cost_so_far[traverse_node])
                traverse_node = came_from[traverse_node]

            if len(path) == 1:
                path.append(start_row_col)
                costs.append(0.0)

            path.reverse()
            costs.reverse()
            result.append((path, costs, end_dict[current_node]))

            end_row_cols.remove(current_node)
            if current_node in end_row_col_list:
                end_row_col_list.remove(current_node)
            if current_node in distance_dic:
                del distance_dic[current_node]

            if len(end_row_cols) == 0 or find_nearest:
                break

        for neighbor in grid.neighbors(current_node):
            new_cost = cost_so_far[current_node] + grid.simple_cost(current_node, neighbor)
            if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                cost_so_far[neighbor] = new_cost
                frontier.put((new_cost, neighbor))
                came_from[neighbor] = current_node

    return result